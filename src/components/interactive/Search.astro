---
interface Props {
    placeholder?: string;
    className?: string;
    type: "articles" | "threads"; // Specify which search type
}

const { placeholder, className, type } = Astro.props;
---

<div class={`w-full col-start-2 -z-1 bg-white pt-2 ${className}`}>
    <div class="relative p-2">
        <div class="w-50 h-13 z-2 border border-6 border-white m-auto">
            <button
                type="button"
                id="searchTrigger"
                class="h-full md:text-base text-sm justify-center gap-2 text-center px-4 flex w-full cursor-pointer border border-black rounded-md bg-gray-900 text-white"
            >
                <div class="flex items-center gap-1">
                    <span class="icon-search text-lg"></span>
                    {placeholder || "Cari artikel..."}
                </div>

                <div class="flex items-center gap-0.5">
                    <span class="icon-command text-sm"></span>
                    K
                </div>
            </button>
        </div>
        <span
            class="block absolute -z-1 top-1/2 h-[1px] bg-gray-300 w-[calc(100%_-_2rem)] left-4 m-auto"
        ></span>
    </div>
</div>

<!-- Search Dialog -->
<dialog
    id="searchDialog"
    class="backdrop:bg-gray-300 backdrop:bg-opacity-50 w-[90%] rounded-lg mx-auto mt-[25vh] max-w-2xl max-h-[50vh]"
    data-search-type={type}
>
    <div
        class="flex-1
    bg-gray-900 flex-col overflow-hidden text-white w-full max-w-2xl max-h-[50vh] rounded-lg shadow-2xl flex-col"
    >
        <!-- Header with close button -->
        <div
            class="flex items-center justify-between p-4 border-b border-gray-700"
        >
            <input
                type="text"
                id="searchInput"
                placeholder={type === "articles"
                    ? "Cari artikel..."
                    : "Cari utas..."}
                class="flex-1 text-lg outline-none bg-transparent text-white placeholder-gray-400"
                autocomplete="off"
            />
            <button
                id="closeDialog"
                class="w-5 h-5 cursor-pointer flex items-center justify-center rounded-full bg-red-500 flex-shrink-0 ml-4"
                aria-label="Close"
            >
                <span class="icon-x text-gray-900 font-bold"></span>
            </button>
        </div>

        <!-- Loading state -->
        <div id="loadingState" class="hidden p-8 text-center text-gray-400">
            Memuat...
        </div>

        <!-- Results container -->
        <div id="searchResults" class="flex-1 overflow-y-auto p-4 max-h-[35vh]">
            <!-- Results will be inserted here -->
        </div>

        <!-- Empty state -->
        <div id="emptyState" class="hidden p-8 text-center text-gray-400">
            <p>
                {
                    type === "articles"
                        ? "Artikel tidak ditemukan"
                        : "Utas tidak ditemukan"
                }
            </p>
        </div>
    </div>
</dialog>

<style is:inline>
    /* Ensure dialog is hidden by default */
    dialog:not([open]) {
        display: none;
    }
</style>

<script>
    import feedLinks from "@/utils/feedLinks";
    import type { FuseResult } from "fuse.js";
    import debounce from "lodash.debounce";

    const worker = new Worker("../../scripts/fuseWorker.mjs", {
        type: "module",
    });

    interface ArticleIndex {
        id: string;
        content: string;
        title: string;
        tags: string[];
    }

    interface ThreadIndex {
        id: string;
        threadId: string;
        title: string;
        content: string;
        article: {
            id: string;
            title: string;
            content: string;
        };
    }

    class Search {
        private dialog: HTMLDialogElement;
        private searchInput: HTMLInputElement;
        private resultsContainer: HTMLElement;
        private emptyState: HTMLElement;
        private loadingState: HTMLElement;
        private searchType: "articles" | "threads";

        constructor() {
            this.dialog = document.getElementById(
                "searchDialog",
            ) as HTMLDialogElement;
            this.searchInput = document.getElementById(
                "searchInput",
            ) as HTMLInputElement;
            this.resultsContainer = document.getElementById("searchResults")!;
            this.emptyState = document.getElementById("emptyState")!;
            this.loadingState = document.getElementById("loadingState")!;
            this.searchType = this.dialog.dataset.searchType as
                | "articles"
                | "threads";

            this.init();
        }

        private async init() {
            // Setup event listeners
            document
                .getElementById("searchTrigger")
                ?.addEventListener("click", () => {
                    this.open();
                });

            document
                .getElementById("closeDialog")
                ?.addEventListener("click", () => {
                    this.close();
                });

            // Close on backdrop click
            this.dialog.addEventListener("click", (e) => {
                if (e.target === this.dialog) {
                    this.close();
                }
            });

            document.addEventListener("keydown", (event) => {
                if (event.key === "k" && (event.metaKey || event.ctrlKey)) {
                    this.open();
                }

                if (event.key === "Escape") {
                    this.close();
                }
            });

            window.onkeydown = function (event) {
                if (event.ctrlKey && event.key == "k") {
                    event.preventDefault();
                }
            };

            // Close on ESC key (dialog handles this automatically)
            this.dialog.addEventListener("close", () => {
                this.cleanup();
            });

            // Search as you type
            this.searchInput.addEventListener(
                "input",
                debounce(() => {
                    this.performSearch();
                }, 300),
            );

            // Load search index
            await this.loadIndex();
        }

        private async loadIndex() {
            this.showLoading();

            try {
                worker.postMessage({
                    type: "init",
                    searchType: this.searchType,
                });

                worker.addEventListener("message", (event) => {
                    if (event.data.type === "init-success") {
                        console.log(event.data.type);
                        this.hideLoading();
                    }
                });
            } catch (error) {
                console.error("Failed to load search index:", error);
                this.hideLoading();
            }
        }

        private open() {
            this.dialog.showModal();
            this.searchInput.focus();
        }

        private close() {
            this.dialog.close();
        }

        private cleanup() {
            this.searchInput.value = "";
            this.resultsContainer.innerHTML = "";
            this.emptyState.classList.add("hidden");
        }

        private showLoading() {
            this.loadingState.classList.remove("hidden");
            this.resultsContainer.classList.add("hidden");
            this.emptyState.classList.add("hidden");
        }

        private hideLoading() {
            this.loadingState.classList.add("hidden");
            this.resultsContainer.classList.remove("hidden");
        }

        private performSearch() {
            const query = this.searchInput.value.trim();
            worker.postMessage({ type: "search", query });

            if (!query) {
                this.resultsContainer.innerHTML = "";
                this.emptyState.classList.add("hidden");
                return;
            }

            worker.addEventListener("message", (event) => {
                if (event.data.type === "search-success") {
                    const results = event.data.data as FuseResult<
                        ArticleIndex | ThreadIndex
                    >[];

                    if (results.length === 0) {
                        this.resultsContainer.innerHTML = "";
                        this.emptyState.classList.remove("hidden");
                        this.resultsContainer.classList.add("hidden");
                        return;
                    }

                    this.resultsContainer.classList.remove("hidden");
                    this.emptyState.classList.add("hidden");
                    this.renderResults(results);
                    console.log(event.data.type);
                }
            });
        }

        private renderResults(results: any[]) {
            this.resultsContainer.innerHTML = "";

            results.forEach((result) => {
                const card =
                    this.searchType === "articles"
                        ? this.createArticleCard(result)
                        : this.createThreadCard(result);

                this.resultsContainer.appendChild(card);
                this.setupFeedLinks();
            });
        }

        private createArticleCard(result: any): HTMLElement {
            const article = result.item as ArticleIndex;
            const card = document.createElement("a");
            card.href = `/articles/${article.id}`;
            card.setAttribute("data-is-feed-link", "1");
            card.setAttribute("data-astro-reload", "1");
            card.className =
                "block p-4 border border-gray-700 rounded-md mb-3 hover:bg-gray-800 transition-colors";

            const title = document.createElement("h3");
            title.className = "font-bold text-md mb-2 text-white";
            title.textContent = article.title;

            const content = document.createElement("p");
            content.className = "text-sm text-gray-300";
            content.innerHTML = this.getHighlightedText(result.matches);

            card.appendChild(title);
            card.appendChild(content);

            return card;
        }

        private createThreadCard(result: any): HTMLElement {
            const thread = result.item as ThreadIndex;
            const card = document.createElement("div");
            card.className =
                "block p-4 border border-gray-700 rounded-md mb-3 hover:bg-gray-800 transition-colors";

            const titleRow = document.createElement("div");
            titleRow.className = "flex items-center gap-1 mb-2";

            const threadTitle = document.createElement("a");
            threadTitle.setAttribute("data-is-feed-link", "1");
            threadTitle.setAttribute("data-astro-reload", "1");
            threadTitle.className =
                "font-bold text-md text-white max-w-[60%] text-ellipsis hover:underline";
            threadTitle.href = `/threads/${thread.threadId}`;
            threadTitle.textContent = thread.title;

            const chevron = document.createElement("span");
            chevron.className = "text-white text-lg icon-chevron-right";

            const articleTitle = document.createElement("a");
            articleTitle.setAttribute("data-is-feed-link", "1");
            articleTitle.setAttribute("data-astro-reload", "1");
            articleTitle.className =
                "font-medium text-md text-white flex-1 line-clamp-1 hover:underline";
            articleTitle.textContent = thread.article.title;
            articleTitle.href = `/articles/${thread.article.id}?thread=${thread.threadId}`;

            titleRow.appendChild(threadTitle);
            titleRow.appendChild(chevron);
            titleRow.appendChild(articleTitle);

            const content = document.createElement("p");
            content.className = "text-sm text-gray-300";
            content.innerHTML = this.getHighlightedText(result.matches);

            const wrapper = document.createElement("a");
            wrapper.href = `/threads/${thread.threadId}`;
            wrapper.setAttribute("data-astro-reload", "1");
            wrapper.appendChild(content);

            card.appendChild(titleRow);
            card.appendChild(wrapper);

            return card;
        }

        private setupFeedLinks(): void {
            feedLinks();
        }

        private getHighlightedText(matches: any[]): string {
            if (!matches || matches.length === 0) return "";

            const match = matches[0];
            if (!match.value) return "";

            let text = match.value;
            const maxLength = 200;

            // Get excerpt around first match
            if (match.indices && match.indices.length > 0) {
                const [start] = match.indices[0];
                const excerptStart = Math.max(0, start - 50);
                const excerptEnd = Math.min(text.length, start + maxLength);
                text =
                    (excerptStart > 0 ? "..." : "") +
                    text.substring(excerptStart, excerptEnd) +
                    (excerptEnd < text.length ? "..." : "");
            } else if (text.length > maxLength) {
                text = text.substring(0, maxLength) + "...";
            }

            // Highlight matches
            if (match.indices) {
                let highlighted = "";
                let lastIndex = 0;

                match.indices.forEach(([start, end]: [number, number]) => {
                    highlighted += text.substring(lastIndex, start);
                    highlighted += `${text.substring(start, end + 1)}`;
                    lastIndex = end + 1;
                });

                highlighted += text.substring(lastIndex);
                return highlighted;
            }

            return text;
        }
    }

    new Search();

    document.addEventListener("astro:after-swap", () => {
        new Search();
    });
</script>
